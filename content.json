[{"title":"如何解决javax.el.PropertyNotFoundException: Property 'RoomNum' not found on XXX","date":"2017-12-04T11:27:13.000Z","path":"2017/12/04/如何解决javax-el-PropertyNotFoundException-Property-RoomNum-not-found-on-XXX/","text":"写代码写到想吐，被分布式数据库的大作业搞得十分心累，由于是自学的SSH框架，直接上手写代码难免会遇到各种问题。新手开车毕竟不稳，前天被一个愚蠢的问题卡了三个小时，在这记录下问题的解决办法。如果大佬们感觉哪有不对，还望不吝指教。 正如题目所说的那样，当我运行我写好的项目准备测试的时候，控制台就抛出了一个： javax.el.PropertyNotFoundException: Property ‘’RoomNum’’ not found on XXX 的错误。 感觉英语再差，也能根据这条错误信息猜出个大概来。 Exception的前缀是PropertyNotFound，也就是说后边双引号中的属性他没找见 于是我们百度一下，发现答案真的多，不过总结起来其实就两种原因： 首先，最有可能的是自定义的javabean里面的属性出了问题（我的属性是“RoomNum”），然后我们定位到自己的javabean，get和set方法肯定不会出问题，毕竟是我们让编译器自动生成的，所以问题出在了属性本身上（我当时就想这个没道理啊，我自己只定义了一个属性名字，怎么会出错）。其实错误就在这个地方，根据javabean的语义规范，在页面中使用el表示时，应该将第一个字母改为小写。所以我们把大小写的问题改过来，问题完美解决。（如果不行，请先尝试下clean下项目和服务器，过几分钟再试一下） 然后，如果你的这个地方没问题，但是还没解决问题，根据网上说的，问题是你这个页面属性前后存在着逻辑问题。所以根据实际情况在做修改，我目前还没遇到过这个问题，先占个坑位，如果今后遇到了再来填坑。 以上，大佬们如果另有指教，欢迎骚扰。E-mail:cliugeek@us-forever.com","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"实现OPEN 哈希表模板类","date":"2017-11-29T13:59:29.000Z","path":"2017/11/29/实现OPEN-哈希表模板类/","text":"第二个算法作业的设计与实现。做的感觉不是很漂亮，希望大家在看完之后能给一些建议，互相学习。 针对同学们给的建议，我对算法进行了相应的修改，具体修改原因在文章末尾给出。 任务要求：任务要求：实现OPEN 哈希表模板类（不得使用C++或JAVA自有的哈希表类）。用哈希表实现一个英语词典（1000个词，在第三个实验中使用） 算法思想： 哈希表也是一种数据结构，它能提供快速的插入和查找的功能。它是基于数组存储数据，因此，它继承了数组的比较好的一个优点，即能在O(1)时间内定位数据。同时，它也有着数组不具有的另一个优点，即对于插入删除操作，它不需要移动大量数据。而它的缺点也很明显，在数组创建后容量固定，如果数据多了之后，我们需要不断扩充容量。 哈希表的存储结构是D（数据元素集）到M（表地址集）的映射，一般的查找方法都是基于关键字比较进行的，所以导致需要定位一个数据元素的位置时，需要做大量的比较。而哈希表的算法思想是通过一种可以直接计算的方式，对于已给定的数据元素key，直接算出key在表中的位置，这样我们的查找就不必进行关键字的比较。 设计思路： 首先我们需要定义一个符合我们自己实际情况的数据类型，按照题目要求，我们的数据类型要存储字符串类型的单词，这个数据结构也应提供初始化函数以及向外部提供我们存储的数据的方法。然后，我们还要设计一个我们自己的哈希表模板类MyHashTable，类中应该包含hash数组，数组长度，初始化函数，哈希函数，增删查三种操作，以及方便我们打印结果的函数。 程序代码： 自定义的数据类型： 123456789101112131415161718package HashTemplateImpl;/** * *@ClassName DataItem.java *@author Leno E-mail:cliugeek@us-forever.com *@date 2017年11月28日下午10:21:03 *@Description 自定义数据类型 */ public class DataItem &#123; private Object iData; //关键字 public DataItem(Object initData)&#123; //构造器 this.iData = initData; &#125; public Object getKey()&#123; //获取关键字 return iData; &#125;&#125; 哈希表模板类的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package HashTemplateImpl;/** * *@ClassName MyHashMap.java *@author Leno E-mail:cliugeek@us-forever.com *@date 2017年11月28日下午9:58:53 *@Description 哈希表模板类实现 */ public class MyHashTable &#123; DataItem[] hashArray; int arraySize;// 定义数组长度 public MyHashTable(int size) &#123;// 构造器，初始化 arraySize = size; hashArray = new DataItem[arraySize]; &#125; // 哈希函数 public int hash(String key) &#123; int h = 0; for (int i = 0; i &lt; key.length(); i++) h = 31 * h + key.charAt(i); return h % arraySize; &#125; // 插入，这里假设是数组未满，即不能插入大于arraySize的数据数 public void insert(DataItem item) &#123; Object key = item.getKey(); String A = key.toString(); int hashCode = hash(A); // 若已存在同样的数据，则向下进一位，直到找到空的位置 // 为了简单，也可要求不准有重复数据 while (hashArray[hashCode] != null) &#123; ++hashCode; hashCode %= arraySize; &#125; hashArray[hashCode] = item; &#125; // 删除 public DataItem delete(DataItem item) &#123; String key = item.getKey().toString(); int hashCode = hash(key); while (hashArray[hashCode] != null) &#123; if (hashArray[hashCode].getKey().toString().equals(key)) &#123; DataItem temp = hashArray[hashCode]; hashArray[hashCode] = null; return temp; &#125; ++hashCode; hashCode %= arraySize; &#125; return null; &#125; // 查找 public DataItem find(DataItem item) &#123; String key = item.getKey().toString(); int hashCode = hash(key); while (hashArray[hashCode] != null) &#123; if (hashArray[hashCode].getKey().toString().equals(key)) return hashArray[hashCode]; ++hashCode; hashCode %= arraySize; &#125; return null; &#125; // 列出全部数据 public void show() &#123; for (int i = 0; i &lt; arraySize; i++) &#123; if (hashArray[i] != null) System.out.print(hashArray[i].getKey() + \" \"); else System.out.print(\"* \"); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; MyHashTable ht = new MyHashTable(10); ht.insert(new DataItem(\"A\")); ht.insert(new DataItem(\"B\")); ht.insert(new DataItem(\"C\")); ht.insert(new DataItem(\"D\")); ht.insert(new DataItem(\"E\")); ht.show(); DataItem i = ht.find(new DataItem(\"C\")); System.out.println(\"i = \"+i.getKey()); DataItem di = ht.delete(new DataItem(\"C\")); System.out.println(\"di = \"+di.getKey()); ht.show(); ht.insert(new DataItem(\"C\")); ht.show(); ht.insert(new DataItem(1)); ht.show(); DataItem f = ht.find(new DataItem(1)); if(f!=null) System.out.println(f.getKey()); else System.out.println(\"找不见\"); DataItem d2 = ht.delete(new DataItem(1)); if(d2!=null) System.out.println(\"d2=\"+d2.getKey()); else System.out.println(\"很难受\"); ht.show(); &#125;&#125; 分析： 以上运行结果符合我们的预期，当第二次插入”C”的时候，程序按照依次寻找下一个空位置的方法，找到了元素”D”后边的第一个空位，当需要删除元素”C”的时候，我们根据hash函数找到第一个存放C的位置，并顺利删除掉了该位置上的数据。该哈希模板适合元素插入不重的情况下使用，如果有相同的元素，例如本例中给的有两个相同的元素插入时，插入操作并不会有任何问题，但是删除操作存在着一定的缺陷，以测试例为例，当成功删除第一个元素C以后，如果再想删除第二个元素C，则会返回null值，在输出打印的时候便会报一个空指针的异常。其实这样的设计也是合理的，如果我们在不知道后续位置是否存在我们想要删除的值的时候，我们需要做遍历整个哈希表的操作，这样会浪费大量的资源，而遍历操作对于我们的哈希表来说，本来就是违背哈希原则的。哈希表的插入删除查找操作的时间复杂度均为O(1)。 博客修改原因： 群众的眼睛是雪亮的，点名感谢郭嘉琪同学。 昨天提交的代码中，DataItem类中的数据只适合String类型的数据，为了让代码更贴切模板类这个说法，我想到的修改是将DataItem中的数据改为了Object类型。如果初始化一个DataItem对象，我所有的操作都是将这个对象的iData字段转化为String类型，然后根据哈希函数求出的位置，再做相应的操作。 另： 如果大家有兴趣，可以看一下哈希函数中那个for循环，里面的31是有讲究的，大家可以自行学习下为啥选的31而不是其他数。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"冒泡排序、快速排序（递归&非递归）、堆排序算法比较浅析","date":"2017-11-28T08:04:34.000Z","path":"2017/11/28/冒泡排序、快速排序（递归-非递归）、堆排序算法比较浅析/","text":"最近算法老师让大家抓紧时间完成算法作业，总共四个题目。这几个题目都很不错，我计划着把这四个作业写成四篇博客，一是可以记录下来供大家分享学习，二是可以提升自己对于这几个算法的理解。 任务要求：实现排序类，公共函数包括冒泡排序、快速排序（递归）、堆排序。将递归算法改写为非递归的，进行比较。 算法思想： （1） 冒泡排序：临近数据的关键码进行两两比较，按照顺序（从小到大或者从大到小）进行交换，这样一趟走过去之后，拥有最大或者最小的关键码的数据被交换到了最后一个位置；然后，再从头开始进行两两比较，直到倒数第二位结束；依照上面的步骤，直到确定第一个位置的数据或者这一组的数据经过一趟冒泡之后不再发生变化时，冒泡排序结束。这样得出的结果序列就是我们预期要得到的有序序列。（2） 快速排序（递归）：任取待排序对象中的某个对象作为基准，按照该对象的关键码大小，将整个对象序列划分为左右两个子序列。其中，左侧子序列中所有的关键码都小于或等于基准对象的关键码；右侧子序列中所有对象的关键码都大于基准对象的关键码。此时基准对象所在的位置也就是该对象在该序列中最终应该安放的位置。然后递归的在左右子序列中重复实施上述的方法，直至所有的对象都放到相应的位置上为止。（3） 快速排序（非递归）：递归的快排算法是编译器自动用栈来实现的，当递归层次比较深的时候，需要占用比较大的进程栈空间，会造成进程栈溢出的危险。因此我们可以自己用栈模拟递归过程，即每次从栈顶取出一部分做划分之后，都把新的两部分的起始位置分别入栈。（4） 堆排序：利用大顶堆（或者小顶堆）堆顶记录的是最大关键字（最小关键字）这一特性，实现对序列的排序。以大顶堆为例。首先，将初始待排序关键字序列（R1，R2…Rn）构建成一个大顶堆，此时的堆为初始的无序区。然后，将堆顶的元素R1与最后一个元素Rn交换，此时得到新的无序区（R1，R2…Rn-1）和新的有序区（Rn），且此时满足R1，R2…Rn-1 &lt;= Rn。经过如上的交换之后，新的顶堆可能违反大顶堆的性质，因此需要对新产生的无序区（R1，R2…Rn-1）进行调整使之成为新的大顶堆，然后再将R1与Rn-1（无序区中最后一个元素）进行交换。不断重复以上过程直至有序区中的元素个数达到n-1个为止，完成整个排序过程。 设计思路： （1） 冒泡排序：冒泡排序需要用到双重循环。首先，实现内层循环，即进行相邻元素之间的比较，该调换顺序的调换顺序，不用调换顺序的进行下一位的比较。其次，再实现外层循环，根据冒泡排序的思想，每次内循环结束后，都会有一个最小值（或者最大值）到达它最终应该到达的位置，因此下一趟内循环的比较次数就减少一次，于是我们应该在外循环中控制内层循环的次数。内层循环结束退出后，外层循环减一再进入内循环。为了防止有序序列已经出现的时候，我们的循环还在运行，不妨设置一个标志位，初始为0，如果在内部循环中发生了交换则将其置为1。如果内层循环结束后，我们的标志位仍为0，则表示我们的序列已经有序，无需再继续执行下去，此时便可以返回当前的有序序列了。（2） 快速排序（递归）：快排的设计思路基于分治法。首先，选取一个元素作为切分元素pivot，然后基于pivot把数组切分为三部分：左子数组（元素小于或者等于pivot），pivot，右子数组（元素大于pivot）。然后，递归地对左右两个子数组进行快速排序，只要保证左右两个子数组分别有序，整个数组也就有序了。（3） 快速排序（非递归）：自己构造一个栈，栈中存放待排序数组的起始位置和终止位置，然后将整个数组的起始位置s和终止位置e入栈，然后从s到e依次对出栈数据进行排序，找到基准数据最终的位置p。在基准位置左侧，判断起始位置s是否小于基准位置p-1，如果小于则将起始位置和新的终点(p-1)位置进栈。同理，在基准位置右侧，判断e是否大于基准位置p+1，若大于则将p+1作为起始位置，e作为终点位置进栈。在这两个新的栈中找到各自的基准数据的最终位置。如此往复直至栈空。（4） 堆排序：堆排序中关键的就是建立大顶堆的过程和调整过程，而调整过程是最为重要的。从最末非叶节点（根据树的结构，不难得出这个位置为Array.length/2向下取整）开始，然后依次往前调整；然后我们再讨论调整过程，首先和当前节点的左子女进行比较，用一个值largest记录比较出来的比较大的那个值的index，然后再让这个largest所代表的值与该节点的右子女进行比较，依旧用largest记录较大值的index，最后比较当前节点与这个largest所代表的值，如果相等说明我们当前节点就是这个三节点两层子树的最大值，如果不相等，我们应该将这个值与我们当前的节点（子树父节点）交换。按照以上步骤建立大顶堆，然后将大顶堆堆顶的值与该树的最后一个节点进行交换，此时便分出来两个区，也就是我们算法思想中提到的无序区和有序区。交换之后的，再对新的Array进行新一轮的调整。为了方便，我同时也实现了一个数组的工具类，它有两个功能，一是打印Array；另一个功能就是实现两个数的交换功能。 程序代码： （1） 冒泡排序： class BubbleSort &#123;1234567891011121314151617181920212223242526 public static void main(String[] args) &#123; // TODO Auto-generated method stub int A[] = &#123; 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 &#125;; BubbleSort(A, 10); for (int i = 0; i &lt; 10; i++) &#123; System.out.print(A[i] + &quot; &quot;); &#125;&#125; public static void BubbleSort(int A[], int n) &#123; boolean flag = false; int temp; for (int i = 0; i &lt; n - 1; i++) &#123; flag = false; for (int j = n - 1; j &gt; i; j--) if (A[j - 1] &gt; A[j]) &#123; temp = A[j - 1]; A[j - 1] = A[j]; A[j] = temp; flag = true; &#125; if (flag == false) return; &#125;&#125;&#125; （2） 快速排序： class QuickSort &#123;1234567891011121314151617181920212223242526272829303132 public static void main(String[] args) &#123; int A[] = &#123; 1, 5, 8, 2, 4, 6, 3, 7, 9, 0 &#125;; int low = 0; int high = A.length - 1; QuickSort(A, low, high); for (int i = 0; i &lt; A.length; i++) &#123; System.out.print(A[i] + &quot; &quot;); &#125;&#125;public static void QuickSort(int A[], int low, int high) &#123; if (low &lt; high) &#123; int pivotpos = Partition(A, low, high); QuickSort(A, low, pivotpos - 1); QuickSort(A, pivotpos + 1, high); &#125;&#125;public static int Partition(int A[], int low, int high) &#123; int pivot = A[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) --high; A[low] = A[high]; while (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125;&#125; （3） 快速排序非递归方式实现： class QuickSortNonRecursion &#123;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 public static void main(String[] args) &#123; int A[] = &#123; 1, 5, 8, 2, 4, 6, 3, 7, 9, 0 &#125;; int low = 0; int high = A.length - 1; nonRec_quickSort(A, low, high); for (int i = 0; i &lt; A.length; i++) &#123; System.out.print(A[i] + &quot; &quot;); &#125;&#125;public static void nonRec_quickSort(int[] a, int start, int end) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if (start &lt; end) &#123; stack.push(end); stack.push(start); while (!stack.isEmpty()) &#123; int l = stack.pop(); int r = stack.pop(); int index = partition(a, l, r); if (l &lt; index - 1) &#123; stack.push(index - 1); stack.push(l); &#125; if (r &gt; index + 1) &#123; stack.push(r); stack.push(index + 1); &#125; &#125; &#125; System.out.println(Arrays.toString(a));&#125;public static int partition(int[] a, int start, int end) &#123; int pivot = a[start]; while (start &lt; end) &#123; while (start &lt; end &amp;&amp; a[end] &gt;= pivot) end--; a[start] = a[end]; while (start &lt; end &amp;&amp; a[start] &lt;= pivot) start++; a[end] = a[start]; &#125; a[start] = pivot; return start;&#125;&#125; （4） 堆排序： 核心代码： class HeapSort &#123;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public static void main(String[] args) &#123; int[] array = &#123; 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3 &#125;; System.out.println(&quot;Before heap:&quot;); ArrayUtils.printArray(array); heapSort(array); System.out.println(&quot;After heap sort:&quot;); ArrayUtils.printArray(array); &#125; public static void heapSort(int[] array) &#123; if (array == null || array.length &lt;= 1) return; buildMaxHeap(array); for (int i = array.length - 1; i &gt;= 1; i--) &#123; ArrayUtils.exchangeElements(array, 0, i); maxHeap(array, i, 0); &#125; &#125; private static void buildMaxHeap(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; int half = array.length / 2; for (int i = half; i &gt;= 0; i--) &#123; maxHeap(array, array.length, i); &#125; &#125; private static void maxHeap(int[] array, int heapSize, int index) &#123; int left = index * 2 + 1; int right = index * 2 + 2; int largest = index; if (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123; largest = right; &#125; if (index != largest) &#123; ArrayUtils.exchangeElements(array, index, largest); maxHeap(array, heapSize, largest); &#125; &#125;&#125; 工具类： class ArrayUtils &#123;1234567891011121314151617 public static void printArray(int[] array) &#123; System.out.print(&quot;&#123;&quot;); for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i]); if (i &lt; array.length - 1) &#123; System.out.print(&quot;,&quot;); &#125; &#125; System.out.println(&quot;&#125;&quot;); &#125; public static void exchangeElements(int[] array, int index1, int index2) &#123; int temp = array[index1]; array[index1] = array[index2]; array[index2] = temp; &#125;&#125; 测试例及运行结果： （1） 冒泡排序：{10,9,8,7,6,5,4,3,2,1} ==&gt; {1,2,3,4,5,6,7,8,9,10}{1,5,8,2,4,6,3,7,9,0} ==&gt; {0,1,2,3,4,5,6,7,8,9}（2） 快速排序（递归与非递归测试例相同）：{10,9,8,7,6,5,4,3,2,1} ==&gt; {1,2,3,4,5,6,7,8,9,10}{1,5,8,2,4,6,3,7,9,0} ==&gt; {0,1,2,3,4,5,6,7,8,9}（3） 堆排序： Before heap: {9,8,7,6,5,4,3,2,1,0,-1,-2,-3} After heap sort:{-3,-2,-1,0,1,2,3,4,5,6,7,8,9} 分析： （1） 冒泡排序：最好情况：对象的初始排列是按关键码从小到大排好序时，此算法只执行一次冒泡排序，做n-1次的关键码比较，不需要移动对象。最坏情况：算法执行了n-1次冒泡，第i次（1&lt;=i&lt;=n）做了n-i次关键码比较，执行了n-i次对象交换。因此这种情况下，总的关键码比较次数KCN和对象移动次数RMN为： 空间复杂度：需要一个附加对象以实现对象值的对换。冒泡排序是一个稳定的排序算法。（2） 快速排序（递归）：快速排序的趟数取决于递归树的深度。 最理想情况下时间复杂度分析：每次划分后，该对象的左右两侧的子序列长度相同。总的时间复杂度T(n)= o(n log2n )最坏情况下时间复杂度分析：每次划分后，有一个子序列是空的，此时T(n)=O(n2)平均情况：T(n)= o(n log2n ) 最好情况下空间复杂度分析：由于算法是递归的，需要一个栈存放每层递归调用时的指针和参数。递归的深度就是树的深度，因此此时的存储开销为o(log2n)。最坏情况下空间复杂度分析：此时递归树为单支树，存储开销为o(n)。 快速排序是不稳定的排序算法。（3） 快速排序（非递归）：该算法对比递归算法，它使用的栈是我们自己创建的栈。而递归方法使用的是程序自动产生的栈，栈中包含了函数调用时的参数和函数中的局部变量。如果局部变量很多或者函数内部有调用了其他函数，这样一来，栈就会变得很大，每次递归调用都要操作很大的栈，效率自然会下降。而我们自己创建的栈，不管程序的复杂度如何，都不会影响程序的效率。该算法的平均情况的时间复杂度仍是o(n log2n )。（4） 堆排序：时间复杂度分析：初始化大顶堆过程每个非叶节点都用到了调整过程的算法，因此该层循环所用时间为： n 其中，i 是层序号，2i 是第 i 层的最大结点数，(k-i-1)是第 i 层结点能够 移动的最大距离。化简后： 调整循环过程：该循环的计算时间为O(nlog2n)。所以，堆排序的时间复杂度为O(nlog2n)。空间复杂度分析：附加存储主要在调整过程中占用，执行交换需要使用一个临时存储空间，因此空间复杂度为O(1)。堆排序是一个不稳定的排序算法。 以上是作业的主要内容，如果有不正确或者有异议的地方，还希望大家不吝指正。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"Deep Learning学习笔记（一）","date":"2017-10-19T01:28:30.000Z","path":"2017/10/19/Deep-Learning学习笔记（一）/","text":"&gt;","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"新的开始","date":"2017-08-31T13:32:57.000Z","path":"2017/08/31/新的开始/","text":"今天是开学第二天，经过大学最后一个暑假的糙磨之后终于迎来了开学，虽然还是我的内蒙古大学，虽然还是计算机学院，但是我对新的开始还是充满了向往。 今年是自治区70周年大庆，内蒙古大学60周年大庆，计算机学院20周年庆，从年初开始呼市就各种修，用欣欣向荣形容这一切可能太过于文雅，暑假之后回来之后确实感觉呼市大变样，花花草草变多了，乱七八糟的广告牌子也整理的比较顺眼了，学校里面更是没得说，最起码有好几段路比原来平整多了。 这两天给我最大的感触就是物是人非，同学们都各奔前程了，学校还是老样子，桃李湖风景依旧。28号的时候来学校这边逛了一圈，偶然遇见了之惠姐姐来学校取档案，还是像往常一样的跟惠姐打了个招呼，聊了几句之后就道别了，但是就在说再见的那一刻才意识到，以后这样的见面的机会也许只能交给缘分了。原来我们真的已经毕业了。 宿舍从本区搬到了东区，原来的六人间变成了四人间。新宿舍上床下桌的环境还是很令人心喜的，宿舍楼底下还有篮球场，虽然没上场打一会，但是只是静静的站在旁边看一会就很令人心满意足了，还有好多学生在灯下玩滑板，还有校园广播中持续不断的流行歌曲，还有好多好多好多好多值得分享的东西。。。。 本科的时候很喜欢跟舍友网吧五连坐，大家一起(｡･∀･)ﾉﾞ嗨，一起玩就感觉很棒，现在更喜欢一个人静静的坐着，听会歌，看看风景，难道是因为我老了？可能只是心气不一样了吧，也可能是因为现在不是很容易找齐5个人再到网吧坐会了吧。 最近最不能释怀的还是我的狼人杀小分队，虽然大家在一起的时光不是很长，但是革命友谊胜过一切，大家一起谈天说地，一起打大A，当然最有意思的狼人杀，还是很怀念那几天的游戏气氛，很棒。还有最后一句，我是预言家（手动滑稽）。 这两天见了导师，认识了新的同学，买了新装备，感觉还是棒棒哒。 明天就是开学典礼了，希望明天又是美好的一天。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://cliugeek9229.github.io/tags/随笔/"}]},{"title":"git 学习总结（二）","date":"2017-06-21T01:09:19.000Z","path":"2017/06/21/git-学习总结2/","text":"没错，这是接着上一次的博客写的。 1.上次说到了日志查看操作，后来在评论区看到了git reflog 命令。 git会记录你的每一次修改HEAD的操作，通过git reflog可以查看所有的历史操作记录，它等同于git log -g 命令。git log命令会显示你所有的提交记录，仅是commit，而git reflog是显示所有操作记录，还包括checkout、merge和reset记录。 2.现在我们既然会查看了，那么接下来就是版本回退了。命令如下： 回退到当前版本的上一个版本 $ git reset –hard HEAD^ 回退到当前版本的上两个版本 $ git reset –hard HEAD^^ 可能机智的你发现了这个^的作用，但是问题又来了，比如你想回到前100个版本，你不会想打100个^吧，这得多虐。那么简便方式来了： $ git reset –hard HEAD~100 其实我们也可以不必数需要回退的版本是当前版本的前多少个版本，通过指定版本号也可以会回退到指定的版本： $ git reset –hard 1234567890 没错，版本号就是你通过git log可以查看到的那串超长的乱七八糟的十六进制数，还有，就是这个版本号写前几位就行，没必要写全，但是也不能太短，能让系统识别出来是哪个版本就行，长度自己斟酌就好。 可能大家会对这个 –hard 参数有疑问，没有？那同学你就太没灵性了。就当大家都有疑问，那这个参数的作用是什么？ 答：git reset操作是撤销了你做的更改，但是除了当前分支上的操作，你可能还需要传入一些标记来修改你的缓存区或工作目录，所以： –soft – 缓存区和工作目录都不会被改变 –mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响 –hard – 缓存区和工作目录都同步到你指定的提交 关于这个知识点，如果你还想再了解些其他的内容，我可以给你提供一个网址，没错，就是 它 。 3.既然我们提到了工作区和版本库，所以就有必要再总结下这俩东西 工作区的概念很简单，就是你本机上的那个文件夹，这个文件夹就是你的工作区，但是不包括其中的.git隐藏文件夹。 版本库就是我们刚才说的这个隐藏文件夹。 其实git的版本库里面有很多的内容，但是我们需要了解的就是其中最为重要的stage（或者index），学名叫做暂存区，此外，git还为我们自动创造了第一个branch，名为master，以及指向master的一个指针，叫做HEAD。 这时候我们就需要盗个图（来自廖雪峰的官方网站-git教程）来解释下他们的关系了。如下： 4.对了，其实有很多简单的操作也需要我们了解。 比如查看修改文件内容，创建删除文件啊之类的操作，其实这些东西大家自己去百度下就能找的到，而且肯定比博主说的详细， 这里 其实有一个网址，我感觉不错，推荐给大家。另外，这也有一个关于vi操作的网址推荐，拿走不蟹。 5.撤销修改 比如我们在工作区中选一个文件并对其进行修改，这时候我们发现，内容写错了，需要将版本回退到我们上次提交时的状态，使用git status命令查看当前状态，然后git就会告诉我们可以用git checkout – &lt; file &gt;来丢弃工作区的修改： $ git checkout – XXX.YYY 其实上面的命令有两种适用情况： （1）文件修改后尚未添加到暂存区，撤销之后就回到了与版本库一样的状态了。 （2）文件修改后我们又将其添加到了暂存区，这个时候我们并没有直接commit，而是又将文件做了新的修改，现在执行撤销修改命令后，文件就回到了添加到暂存区之后的状态了。 也就是说这个命令可以使文件回到最近一次git commit或者git add时的状态。 比如说你现在正处于第二种状态，通过git checkout – XXX.YYY命令已经将你写的第二次错误撤销了，但是你提交给暂存区的文件里仍存有你的第一次错误，所以你还需要将暂存区的文件再给撤销回来，此时同样使用git status命令查看下当前的状态，此时git会告诉你使用git reset HEAD file可以将暂存区的修改撤销掉（也就是以unstage结尾的那句话），并将其重新放回到工作区： $ git reset HEAD XXX.YYY 此时如果你用git status查看当前状态就会发现，changes not staged for commit，也就是说咱们的暂存区是干净的，但是工作区是有修改的，所以你可以再使用git checkout命令将你需要撤销的东西撤销了，或者直接手动修改文件，如果你记得需要改什么东西的话。 有灵性的同学可能又会问，我如果不仅git add了，而且git commit了，但是并没有将本地的版本库推送到远程，我们怎么办呢？其实很简单，版本回退不就好了~~~这时候可能又有有问题的同学举手说，我要是也将本地的版本库推送到了远程怎么办？额。。。我只能告诉你Good Game了，所以大家提交东西的时候一定要慎之又慎，尤其是推送到远端的时候。 6.文件删除。 这个就比较简单了，我们都知道在文件管理器中我们可以使用rm file命令就可以删除相应的文件，要是我们想删除版本库的某个文件怎么办？也很简单，使用git rm file就可以删除相应的文件，但是我们还需要再commit一下，告诉一下版本库我们的修改： $ git rm XXX.YYY $ git commit -m “romove balabala~~~~” 这样我们就完成了对版本库中的文件的删除操作。 如果你是不小心将工作区的文件删除了怎么办？这时候我们的版本库中仍然有相应的文件，我们只需要恢复下这个文件即可： $ git checkout – XXX.YYY git checkout 其实就是将版本库里的版本替换掉工作区的版本。这样你就获取到了版本库中最新的一次版本，但是你如果在XXX.YYY中已经修改了部分信息，而这部分信息也会随着你的误删丢失了，所以，小心看护你的工作区。 以上，是我对于廖神的git教程中时光机穿梭这一章的总结。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"git 学习总结（一）","date":"2017-06-20T14:27:37.000Z","path":"2017/06/20/git-学习总结/","text":"最近把廖神的git教程重温一遍，这篇博客主要是针对git中的命令，稍作总结。 1.博主的环境是win10，按照默认配置安装完git。之后，我们需要设置我们自己的用户名和默认的邮箱地址。 右键桌面，在出现的菜单中选择“Git Bash”选项，通过cd命令到达指定的文件夹下【或者你直接到指定的目目录下之后，然后右键空白处点击右键然后选择git bash here选项】，再通过键入以下命令完成设置： $ git config –global user.name “Leno” $ git config –global user.email “XXX@YYY.com” 注意下这里的–global参数，这个参数说明我们当前机器下的所有的git仓库都是用的这个用户名和邮箱。 2.创建版本库。 $ git init 3.分两步，将文件添加到git仓库。 3.1 将文件添加到暂存区（可多次添加文件，也可一次添加多个文件） $ git add XXX.YYY 3.2 将文件添提交到仓库 $ git commit -m “bala~bala~bala~” 4.查阅当前仓库的状态 $ git status 5.查阅文件具体被修改的内容 $ git diff XXX.YYY 6.查看从最近到最远的提交日志 $ git log 当然，这种显示日志简直low到炸，这时候我们可以通过一个参数添加达到让这些日志显示到一行上，具体命令如下： $ git log –pretty=oneline 这样显示出来的日志结果倒是简洁了不少，但是还不是令人特别满意，那么此时你可以试一下以下的这串命令： $ git log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit 这时候你会说，我不就是想看一下日志嘛，如果每次都输入这么一长串的命令，这样会耽误很长的时间，那岂不是很蠢。。。也对，每次都输入这么一长串命令确实斯丢屁德，那么怎么办呢，方法还是有的，既然你来访问我的博客，那你我就是有缘人，既然是有缘人，那我就不吝指教了。我们可以通过配置别名的方法来简化以上的这行命令，如下： $ git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit” 这样配置完之后，你再试一下： $ git lg 意不意外？惊不惊喜？高不高兴？关于配置别名在后边会又详细的叙述，今天就先到这。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"忙点好~忙点好~","date":"2017-06-16T11:58:20.000Z","path":"2017/06/16/忙点好-忙点好/","text":"这几天还真的是挺忙的，这样其实也挺充实的，最起码可以不让我老是窝宿舍。 其实这几天感触还是很多的，先是整理学籍表，自己忙了一天半还多，最让人心寒的是干活的时候叫人叫不来，回家的、去工作的我都能理解，大家其实都很忙，我真的能理解，但是，我最不能理解的就是装作没这回事的同学，还有因为在打游戏不能帮忙的，简直想送他们一句mmp。 毕竟大家在一起的日子也不是很多了，本来站好最后一班岗也是情理之中，但是大家对我们工作的支持态度也太差了，这个绝对是班委的预料之外的。。。 现在想想其实自己的问题也很大，做事不能太耿直，也不能一不顺心就摔脸子，这样不但不能解决问题，而且还会使得矛盾激化，以后可得好好收敛下自己的情绪了，不能想个小孩一样。 今天又被教务处抓去做了次壮丁，说好的只是核对班级的毕业信息，结果各种活都来了。。。先是去抱本科生的期末试卷，然后又是毕业证和学位证，可是累的不轻。 这几天虽然有些累，但总的来说，还是不错的。 现在洗脚听歌写博客也是很惬意的~~希望明天的六级考试能上300分吧，作为一名裸考考生，300我就已经很知足了【手动捂脸】","tags":[{"name":"随笔","slug":"随笔","permalink":"http://cliugeek9229.github.io/tags/随笔/"}]},{"title":"博客处女作","date":"2017-06-07T13:37:06.000Z","path":"2017/06/07/博客处女作/","text":"欢迎大家来到我的博客！在旭哥哥不懈地指导下，我的博客总算是搭建起来了。在这个博客上面我会不定期地发布个人随笔、读书笔记等。 去年冬天的时候就已经在廖雪峰的官方网站上学习过git的相关知识了，但仅仅只是学习一些基本的操作，并没有具体的将它用于项目中，结果就是感动了自己，浪费了时间，最后也没有学到多少东西，简直斯丢匹德。 学习其实不仅仅只是态度的问题，方法也很重要，以后这种感动自己的事还是不干的好… 本来想着关于技术博客也写在这个博客上，但是想到如果这样的话，无法供世人瞻仰，所以我准备把技术相关的博客写到CSDN上，这样的话，也是极好的。 现在这个写作水平啊，也是没谁了（手动无奈）。 最后还是欢迎大家常来我的博客逛一逛，当然，要是能顺便关爱一下博主就更好了（手动滑稽）。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://cliugeek9229.github.io/tags/随笔/"}]}]