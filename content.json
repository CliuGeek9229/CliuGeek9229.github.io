[{"title":"LeetCode刷题：第12题Integer to Roman","date":"2018-03-07T14:15:54.000Z","path":"2018/03/07/LeetCode刷题：第12题Integer-to-Roman/","text":"题目之前就完成了，今天补博客~ 题目要求：Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 拼写规则： 罗马数字的拼写规则我有在上一篇博客中写到，请大家自行查阅。同样，我们给出罗马字符对应的阿拉伯数字表格。 字母 M D C L X V I 代表数字 1000 500 100 50 10 5 1 设计思路：针对这个题，解法同样也有很多，这里我介绍的是我认为比较简单明了的解法。 每两个level之间要用一个减法操作，为什么这么说呢，举个栗子：4，根据规则我们不能用IIII表示而是表示为IV，这个减法同样在9，40，90，400，900的时候使用，so这几种情况也不是很繁琐，我们列个数组把它们表示出来就好惹~ 同样遍历顺序从前往后，本着贪心的算法思想，每次从前往后选出最大的字符表示，然后把对应的罗马字符串联起来，也就能完成这道题了。代码如下： 实现代码： 1234567891011121314151617181920212223242526272829303132package leetcode;/** * * @ClassName IntegerToRoman.java * @author Leno E-mail:cliugeek@us-forever.com * @date 2018年3月7日上午11:36:46 * @Description Given an integer, convert it to a roman numeral. * * Input is guaranteed to be within the range from 1 to 3999. */public class IntegerToRoman &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(intToRoman(99)); &#125; public static String intToRoman(int num) &#123; String result = \"\"; String keys[] = &#123; \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" &#125;; int values[] = &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; for(int i = 0;num!=0;i++)&#123; while(num&gt;=values[i])&#123; num-=values[i]; result+=keys[i]; &#125; &#125; return result; &#125;&#125;","tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://cliugeek9229.github.io/tags/LeetCode刷题/"}]},{"title":"LeetCode刷题：第13题Roman to Integer","date":"2018-03-06T12:28:49.000Z","path":"2018/03/06/LeetCode刷题：第13题Roman-to-Integer/","text":"开始本周的刷题~ 题目要求：Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 拼写规则：要想了解如何解决这个问题，我们第一步肯定要了解罗马数字的编码规则，这里有一条关于编码规则的超链，拿去不谢。但是为了读者方便，这里给出一个关于罗马字母与阿拉伯数字对应的表格。 字母 M D C L X V I 代表数字 1000 500 100 50 10 5 1 设计思路：其实这个题不是很难，解法也有很多，但是这里我想介绍的是我认为相对有点意思的解法。本着左加右减的设计规则，我们对罗马数字转换为阿拉伯数字的时候也要比较相邻两个数字的大小。 遍历顺序从前往后，所以对于第一个符号来说，我们直接读取它代表的数字就可以了。如果当前符号代表的数字比它前一个符号代表的数字小或者相等，例如：VII，初始化为5，第一轮循环I是比V小的，所以我们需要加上该数，也就是5+1 = 6，第二轮I = I，同样6+1 = 7；反之，当前符号代表的数字比它之前的一个符号代表的数字大，我们需要减去前一个数的两倍然后加上该数，例如：XIV，初始化为10，第一轮循环II,11 - 1*2+5 = 14。所以不难看出这个方法还是很nice的，而且代码实现起来不会杂乱无章，如下。 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class RomantoInteger &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(romanToInteger(\"DCXXI\")); &#125; public static int romanToInteger(String s)&#123; int i, total, pre, cur; total = charToInt(s.charAt(0)); for (i = 1; i &lt; s.length(); i++) &#123; pre = charToInt(s.charAt(i - 1)); cur = charToInt(s.charAt(i)); if (cur &lt;= pre) &#123; total += cur; &#125; else &#123; total = total - pre * 2 + cur; &#125; &#125; return total; &#125; public static int charToInt(char c) &#123; int currentResult = 0; switch (c) &#123; case 'I': currentResult = 1; break; case 'V': currentResult = 5; break; case 'X': currentResult = 10; break; case 'L': currentResult = 50; break; case 'C': currentResult = 100; break; case 'D': currentResult = 500; break; case 'M': currentResult = 1000; break; &#125; return currentResult; &#125; &#125;","tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://cliugeek9229.github.io/tags/LeetCode刷题/"}]},{"title":"LeetCode刷题：第9题PalindromeNumber","date":"2018-03-03T02:25:51.000Z","path":"2018/03/03/LeetCode刷题：第9题PalindromeNumber/","text":"正月十六，这个年算是彻底过完了，也该开始干活了。在LeetCode上做的第二道题，详细内容如下： 题目要求：Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 思路分析：题目要求很简单，判断一个integer类型的数是否为回文数，但是要求不允许使用额外的空间，所以我们不可能考虑通过将integer转换成string后再进行convert，也就是问题提示中的第二条内容。再看下官方给的提示第一条，负数不可能是回文数，这里讲的就是一个边界问题，所以代码编写的时候肯定先去除这种边界之外的情况。接着看第三条提示，也就是将我们的integer整个reverse，系统提示我们会出现整数溢出问题，所以这种方法我们也不能再考虑了。 所以综上，我们只能使用数学计算的方法解决本题，而且还不能将我们的目标target整个reverse，所以我们只能考虑将目标target部分reverse，而这个“部分”的量是多少？因为是回文数，所以不难想出这个“部分”的大小就是一半。 那么问题又来了，这个一半的大小如何判断，什么时候我们找到了target的一半的数字？其实也不是很难，举个例子，对于12321来说，我们肯定要先获得个位，也就是12321%10 == 1，然后在将12321/10 = 1232，再将1232%10 =2，将之前的1*10再加上2，以此类推，所以我们通过我们得到的revert与“原数x”（其实并不是实际意义上的原数，而是每步都除以10之后的数）比较，如果“原数x”比revert小的时候，说明我们就已经处理了一半的数字了。 代码实现：123456789101112public static boolean isPalindrome(int x)&#123; if(x&lt;0 || (x%10 == 0 &amp;&amp; x!=0)) return false; int revert = 0; while(x&gt;revert)&#123; revert = revert*10+x%10; x = x/10; &#125; if(x == revert || x == revert/10) return true; return false; &#125;","tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://cliugeek9229.github.io/tags/LeetCode刷题/"}]},{"title":"LeetCode刷题：第1题Two Sum","date":"2018-02-26T11:12:58.000Z","path":"2018/02/26/LeetCode刷题：第1题Two-Sum/","text":"听从老姐的建议，开始在LeetCode上刷题，争取每周能保质保量的完成2到3道题，每道题我都会以博客的形式将其中的原理以及各种算法都展现出来。 题目要求：Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路1：题目要求让我们在一个数组中找到两个不重复的数，并且和为target，输出两个数的下标。思路就是两重循环，外层i从第一个数，内层j每次从最后一个数开始，往前面走，遇到i就停止，跳出的条件为i，j两数之和为target。这个思路比较简单，很容易理解，但是相对的时间复杂度就很高，两重循环的时间复杂度为O(n^2)。 实现代码： 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=nums.length-1;j&gt;i;j--)&#123; if(nums[i]+nums[j] == target)&#123; result[0] = i; result[1] = j; break; &#125; &#125; &#125; return result; &#125;&#125; 思路2：其实这个思路我自己并没有想到，在借鉴题目附带的solution之后，才恍然大悟。思路1中我们讲到最直接的蛮力法就是两重循环，相对的时间复杂度也到达了O(n^2),所以为了减少时间复杂度，我们需要一种更加有效的方法检查数组中是否存在补码，即相对于nums[i],其补码为target-nums[i],假设存在这样的补码，其索引为j,为了满足题目要求，此时的i和j不能为同一个数。如果存在我们只需得到它的索引（下标）即可,而查找这种索引的的映射最佳方法是散列表，这个过程也就是空间换取时间的做法。因为哈希表支持在接近恒定时间内快速查找，所谓“近”的意思就是如果发生碰撞，时间复杂度可能退化到O(n),所以需要仔细选择散列函数就能保证近O(1)查找的时间复杂度。 实现代码： 1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt;= nums.length - 1; i++) map.put(nums[i], i); for(int i = 0;i&lt;nums.length;i++)&#123; int complement = target -nums[i]; if(map.containsKey(complement) &amp;&amp; map.get(complement)!=i)&#123; result[0] = i; result[1] = map.get(complement); break; &#125; &#125; return result; &#125;&#125; 补充：我们最终为了拿到的是下标，所以在map中key选用的是数组中的值，value选用的是数组中每个值对应的下标。此时我们的算法时间复杂度为O(n)，我们遍历了两次n个元素，虽然散列表将查找的时间复杂度降为了O(1)，但此时的总的时间复杂度为O(n)。 思路3：其实算不上思路三，这个思路和思路二是一样的，但是它在思路二的基础上优化了代码，我们原本需要两次循环才能完成的任务其实在一次循环中即可完成。试想，在一次循环中我们直接检测当前的map中是否含有当前元素的补码，如果存在那就说明我们找见了这两个数，只需输出各自的下标即可；否则，我们需要我们就把当前元素放到map中。如此一来一次循环即可完成任务。 实现代码： 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0;i&lt;nums.length;i++)&#123; int complement = target-nums[i]; if(map.containsKey(complement))&#123; result[0] = map.get(complement); result[1] = i; &#125; map.put(nums[i], i); &#125; return result; &#125;&#125; 对比：下图的runtime由下到上是对应的这三个解决办法，结果不言而喻。","tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"http://cliugeek9229.github.io/tags/LeetCode刷题/"}]},{"title":"tensorflow学习心得：numpy中newaxis的使用","date":"2018-01-15T09:02:09.000Z","path":"2018/01/15/tensorflow学习心得：numpy中newaxis的使用/","text":"小知识点，当作学习笔记记录一下。 newaxis的功能其实很简单，主要就是加入一个新的维度，大家可以参照我下面给出的例子，自行理解！ 示例： 1234567891011import numpy as npx_data = np.linspace(-1,1,3)y_data = np.linspace(-1,1,3)[:,np.newaxis]z_data = np.linspace(-1,1,3)[np.newaxis,:]print(x_data.shape)print(y_data.shape)print(z_data.shape)print(x_data)print(y_data)print(z_data) 结果： 12345678(3,)(3, 1)(1, 3)[-1. 0. 1.][[-1.] [ 0.] [ 1.]][[-1. 0. 1.]] 注：linspace函数的功能是创建等差数列，例子中给定了三个参数，意思分别是开始元素，结束元素，生成等差数列中的元素个数。我给的例子中的意思就是从-1到1，生成具有3个元素的等差数列，所以生成的结果为[-1. 0. 1.]。 y_data为x_data在列中加了一个列的维度；z_data为x_data加了一个行的维度。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"拼写错误检测(动态规划法)","date":"2017-12-08T02:41:44.000Z","path":"2017/12/08/拼写错误检测-动态规划法/","text":"最近忙于完成分布式数据库大项目的代码，算法作业也因此被搁置了好几天。分布式代码终于敲完交上去了，现在有时间继续完成算法作业了。其实算法作业并不是很难，大家仔细分析下问题，多搜搜博客，学习下前辈们如何解决这类问题，问题其实很容易解决的！只有站在前人的肩膀上，我们才能取得更大的进步，同时塑造更好的自己（不管了，我就是想写小学生作文~~~）！我还是本着原来的想法，我把我的思路和设计的关键部分贴出来，大家分享学习，全部的代码我不会放出来，原因很简单，我不是很想让大家都交雷同作业，也希望大家能理解。下面开始我们的第三个算法的设计与实现吧。 任务要求：以第2题中的哈希表英语词典为基础，应用动态规划法设计和实现拼写错误检测程序。 对输入单词进行检测，如果不正确，给出最接近的3个可选词。 算法思想： 首先我们要讲一个名词：编辑距离（EditDistance）【又称Levenshtein距离】：对于两个字符串，由一个转换为另一个所需的最少编辑操作次数。其中许可的编辑操作包括将一个字符替换成为另一个字符，插入一个字符，删除一个字符。 想了一个简单直观的例子，帮助大家理解以上两句话： 输入待查对象：kittain，我们字典中的一个对象sitting，我们求他俩的最短编辑距离的时候的步骤为： sittain(k-&gt;s替换); sittin(删掉a); sitting(插入g)。 但是电脑毕竟不是人脑，它没有思想，它一眼看不出来我们上述的操作，但是它擅长搜索啊，计算啊。所以我们一个字母一个字母的开始做比较。 首先想我们算最终的编辑距离是不是得依赖前面算得的编辑距离，我们是不是得层层递归，才能算出从字符串a到字符串b的编辑距离，所以我们使用了分治的思想，将一个复杂的问题分解为类似的子问题。 所以我们先按照递归的思想： 字符串a，共m位，从a[1]到a[m] 字符串b，共n位，从b[1]到b[n] d[i][j]表示字符串a到b的编辑距离。 按照递归的思想做解决这个问题（a[i]和b[j]为a,b的最后一位）： &lt;1&gt;当a[i]=b[j],d[i][j] = d[i-1][j-1] &lt;2&gt;当d[i]!=b[j],d[i][j]等于如下三项的最小值： ·d[i-1][j]+1(删除a[i]) ·d[i][j-1]+1(插入b[j]) ·d[i-1][j-1]+1(将a[i]替换成b[j]) 递归的边界： ·a[i][0] = i,b字符串为空，表示将a[1]到a[i]全部删除，所以编辑距离为i； ·a[0][i] = j,a字符串为空，表示将b[1]到b[j]全部插入，所以编辑距离为j。 优化：（动态规划解决冗余）以上的设计思路中存在着严重的问题，由于采用了递归，导致代码的效率很低下，时间复杂度呈指数增长，也存在这大量的重复字问题的计算，解决这种冗余的办法就是用动态规划。 递归的解决思路是从后往前算的，也就是我们想的到d[i][j],就必须先得到 d[i][j-1]、d[i-1][j]、d[i-1][j-1]三者中的最小。 而动态规划的思想恰恰相反，它的思想就是从前往后算，先算出各个子问题，然后根据子问题，计算得出原问题，因此可以解决大量出现的冗余问题。 设计思路： 首先，在第二题的代码中，我给出了一个find()函数，这个函数的作用是根据我所输入的待查找字符串，计算出hashCode，然后去我的哈希表里面查找这个字符串，如果存在的话，可以直接返回该字符串对应的对象。因为hash表查找比我的编辑距离（Edit Distance）计算相似距离的方法快（编辑距离是循环hash表，表中每个单词都做比对），所以我们首先使用hash表的find方法查找输入的单词是不是正确的单词，如果不是，我们再使用动态规划优化后的编辑距离计算相似距离的方法找出三个最为相似的单词输出。 程序代码： 动态规划求编辑距离的核心代码： 1234567891011121314151617181920212223242526272829303132333435363738package tst; /** * *@ClassName EditDistance.java *@author Leno E-mail:cliugeek@us-forever.com *@date 2017年12月7日下午1:28:27 *@Description 动态规划思想求编辑距离，从前往后算 */public class EditDistance &#123; public int min(int a,int b,int c)&#123; int tmp = a&lt;b?a:b; return tmp&lt;c?tmp:c; &#125; public int edit_distance(String a,String b)&#123; int lena = a.length(); int lenb = b.length(); int d[][] = new int[lena+1][lenb+1]; int i = 0 , j = 0; for(i=0;i&lt;=lena;i++)&#123; d[i][0] = i; &#125; for(j=0;j&lt;=lenb;j++)&#123; d[0][j] = j; &#125; for(i=1;i&lt;=lena;i++)&#123; for(j=1;j&lt;=lenb;j++)&#123; if(a.charAt(i-1) == b.charAt(j-1))&#123; d[i][j] = d[i-1][j-1]; &#125;else&#123; d[i][j] = min(d[i-1][j]+1,d[i][j-1]+1,d[i-1][j-1]+1); &#125; &#125; &#125; return d[lena][lenb]; &#125;&#125; 测试例和运行结果： 这次的测试例给的比较多，我随便输入了几个单词进行了相应的测试，结果如下： 以上是本次作业的核心实现部分，如果有不正确的地方，还希望大家不吝指正。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"如何解决javax.el.PropertyNotFoundException: Property 'RoomNum' not found on XXX","date":"2017-12-04T11:27:13.000Z","path":"2017/12/04/如何解决javax-el-PropertyNotFoundException-Property-RoomNum-not-found-on-XXX/","text":"写代码写到想吐，被分布式数据库的大作业搞得十分心累，由于是自学的SSH框架，直接上手写代码难免会遇到各种问题。新手开车毕竟不稳，前天被一个愚蠢的问题卡了三个小时，在这记录下问题的解决办法。如果大佬们感觉哪有不对，还望不吝指教。 正如题目所说的那样，当我运行我写好的项目准备测试的时候，控制台就抛出了一个： javax.el.PropertyNotFoundException: Property ‘’RoomNum’’ not found on XXX 的错误。 感觉英语再差，也能根据这条错误信息猜出个大概来。 Exception的前缀是PropertyNotFound，也就是说后边双引号中的属性他没找见 于是我们百度一下，发现答案真的多，不过总结起来其实就两种原因： 首先，最有可能的是自定义的javabean里面的属性出了问题（我的属性是“RoomNum”），然后我们定位到自己的javabean，get和set方法肯定不会出问题，毕竟是我们让编译器自动生成的，所以问题出在了属性本身上（我当时就想这个没道理啊，我自己只定义了一个属性名字，怎么会出错）。其实错误就在这个地方，根据javabean的语义规范，在页面中使用el表示时，应该将第一个字母改为小写。所以我们把大小写的问题改过来，问题完美解决。（如果不行，请先尝试下clean下项目和服务器，过几分钟再试一下） 然后，如果你的这个地方没问题，但是还没解决问题，根据网上说的，问题是你这个页面属性前后存在着逻辑问题。所以根据实际情况在做修改，我目前还没遇到过这个问题，先占个坑位，如果今后遇到了再来填坑。 以上，大佬们如果另有指教，欢迎骚扰。E-mail:cliugeek@us-forever.com","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"实现OPEN 哈希表模板类","date":"2017-11-29T13:59:29.000Z","path":"2017/11/29/实现OPEN-哈希表模板类/","text":"第二个算法作业的设计与实现。做的感觉不是很漂亮，希望大家在看完之后能给一些建议，互相学习。 针对同学们给的建议，我对算法进行了相应的修改，具体修改原因在文章末尾给出。 任务要求：任务要求：实现OPEN 哈希表模板类（不得使用C++或JAVA自有的哈希表类）。用哈希表实现一个英语词典（1000个词，在第三个实验中使用） 算法思想： 哈希表也是一种数据结构，它能提供快速的插入和查找的功能。它是基于数组存储数据，因此，它继承了数组的比较好的一个优点，即能在O(1)时间内定位数据。同时，它也有着数组不具有的另一个优点，即对于插入删除操作，它不需要移动大量数据。而它的缺点也很明显，在数组创建后容量固定，如果数据多了之后，我们需要不断扩充容量。 哈希表的存储结构是D（数据元素集）到M（表地址集）的映射，一般的查找方法都是基于关键字比较进行的，所以导致需要定位一个数据元素的位置时，需要做大量的比较。而哈希表的算法思想是通过一种可以直接计算的方式，对于已给定的数据元素key，直接算出key在表中的位置，这样我们的查找就不必进行关键字的比较。 设计思路： 首先我们需要定义一个符合我们自己实际情况的数据类型，按照题目要求，我们的数据类型要存储字符串类型的单词，这个数据结构也应提供初始化函数以及向外部提供我们存储的数据的方法。然后，我们还要设计一个我们自己的哈希表模板类MyHashTable，类中应该包含hash数组，数组长度，初始化函数，哈希函数，增删查三种操作，以及方便我们打印结果的函数。 程序代码： 自定义的数据类型： 123456789101112131415161718package HashTemplateImpl;/** * *@ClassName DataItem.java *@author Leno E-mail:cliugeek@us-forever.com *@date 2017年11月28日下午10:21:03 *@Description 自定义数据类型 */ public class DataItem &#123; private Object iData; //关键字 public DataItem(Object initData)&#123; //构造器 this.iData = initData; &#125; public Object getKey()&#123; //获取关键字 return iData; &#125;&#125; 哈希表模板类的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package HashTemplateImpl;/** * *@ClassName MyHashMap.java *@author Leno E-mail:cliugeek@us-forever.com *@date 2017年11月28日下午9:58:53 *@Description 哈希表模板类实现 */ public class MyHashTable &#123; DataItem[] hashArray; int arraySize;// 定义数组长度 public MyHashTable(int size) &#123;// 构造器，初始化 arraySize = size; hashArray = new DataItem[arraySize]; &#125; // 哈希函数 public int hash(String key) &#123; int h = 0; for (int i = 0; i &lt; key.length(); i++) h = 31 * h + key.charAt(i); return h % arraySize; &#125; // 插入，这里假设是数组未满，即不能插入大于arraySize的数据数 public void insert(DataItem item) &#123; Object key = item.getKey(); String A = key.toString(); int hashCode = hash(A); // 若已存在同样的数据，则向下进一位，直到找到空的位置 // 为了简单，也可要求不准有重复数据 while (hashArray[hashCode] != null) &#123; ++hashCode; hashCode %= arraySize; &#125; hashArray[hashCode] = item; &#125; // 删除 public DataItem delete(DataItem item) &#123; String key = item.getKey().toString(); int hashCode = hash(key); while (hashArray[hashCode] != null) &#123; if (hashArray[hashCode].getKey().toString().equals(key)) &#123; DataItem temp = hashArray[hashCode]; hashArray[hashCode] = null; return temp; &#125; ++hashCode; hashCode %= arraySize; &#125; return null; &#125; // 查找 public DataItem find(DataItem item) &#123; String key = item.getKey().toString(); int hashCode = hash(key); while (hashArray[hashCode] != null) &#123; if (hashArray[hashCode].getKey().toString().equals(key)) return hashArray[hashCode]; ++hashCode; hashCode %= arraySize; &#125; return null; &#125; // 列出全部数据 public void show() &#123; for (int i = 0; i &lt; arraySize; i++) &#123; if (hashArray[i] != null) System.out.print(hashArray[i].getKey() + \" \"); else System.out.print(\"* \"); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; MyHashTable ht = new MyHashTable(10); ht.insert(new DataItem(\"A\")); ht.insert(new DataItem(\"B\")); ht.insert(new DataItem(\"C\")); ht.insert(new DataItem(\"D\")); ht.insert(new DataItem(\"E\")); ht.show(); DataItem i = ht.find(new DataItem(\"C\")); System.out.println(\"i = \"+i.getKey()); DataItem di = ht.delete(new DataItem(\"C\")); System.out.println(\"di = \"+di.getKey()); ht.show(); ht.insert(new DataItem(\"C\")); ht.show(); ht.insert(new DataItem(1)); ht.show(); DataItem f = ht.find(new DataItem(1)); if(f!=null) System.out.println(f.getKey()); else System.out.println(\"找不见\"); DataItem d2 = ht.delete(new DataItem(1)); if(d2!=null) System.out.println(\"d2=\"+d2.getKey()); else System.out.println(\"很难受\"); ht.show(); &#125;&#125; 分析： 以上运行结果符合我们的预期，当第二次插入”C”的时候，程序按照依次寻找下一个空位置的方法，找到了元素”D”后边的第一个空位，当需要删除元素”C”的时候，我们根据hash函数找到第一个存放C的位置，并顺利删除掉了该位置上的数据。该哈希模板适合元素插入不重的情况下使用，如果有相同的元素，例如本例中给的有两个相同的元素插入时，插入操作并不会有任何问题，但是删除操作存在着一定的缺陷，以测试例为例，当成功删除第一个元素C以后，如果再想删除第二个元素C，则会返回null值，在输出打印的时候便会报一个空指针的异常。其实这样的设计也是合理的，如果我们在不知道后续位置是否存在我们想要删除的值的时候，我们需要做遍历整个哈希表的操作，这样会浪费大量的资源，而遍历操作对于我们的哈希表来说，本来就是违背哈希原则的。哈希表的插入删除查找操作的时间复杂度均为O(1)。 博客修改原因： 群众的眼睛是雪亮的，点名感谢郭嘉琪同学。 昨天提交的代码中，DataItem类中的数据只适合String类型的数据，为了让代码更贴切模板类这个说法，我想到的修改是将DataItem中的数据改为了Object类型。如果初始化一个DataItem对象，我所有的操作都是将这个对象的iData字段转化为String类型，然后根据哈希函数求出的位置，再做相应的操作。 另： 如果大家有兴趣，可以看一下哈希函数中那个for循环，里面的31是有讲究的，大家可以自行学习下为啥选的31而不是其他数。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"冒泡排序、快速排序（递归&非递归）、堆排序算法比较浅析","date":"2017-11-28T08:04:34.000Z","path":"2017/11/28/冒泡排序、快速排序（递归-非递归）、堆排序算法比较浅析/","text":"最近算法老师让大家抓紧时间完成算法作业，总共四个题目。这几个题目都很不错，我计划着把这四个作业写成四篇博客，一是可以记录下来供大家分享学习，二是可以提升自己对于这几个算法的理解。 任务要求：实现排序类，公共函数包括冒泡排序、快速排序（递归）、堆排序。将递归算法改写为非递归的，进行比较。 算法思想： （1） 冒泡排序：临近数据的关键码进行两两比较，按照顺序（从小到大或者从大到小）进行交换，这样一趟走过去之后，拥有最大或者最小的关键码的数据被交换到了最后一个位置；然后，再从头开始进行两两比较，直到倒数第二位结束；依照上面的步骤，直到确定第一个位置的数据或者这一组的数据经过一趟冒泡之后不再发生变化时，冒泡排序结束。这样得出的结果序列就是我们预期要得到的有序序列。（2） 快速排序（递归）：任取待排序对象中的某个对象作为基准，按照该对象的关键码大小，将整个对象序列划分为左右两个子序列。其中，左侧子序列中所有的关键码都小于或等于基准对象的关键码；右侧子序列中所有对象的关键码都大于基准对象的关键码。此时基准对象所在的位置也就是该对象在该序列中最终应该安放的位置。然后递归的在左右子序列中重复实施上述的方法，直至所有的对象都放到相应的位置上为止。（3） 快速排序（非递归）：递归的快排算法是编译器自动用栈来实现的，当递归层次比较深的时候，需要占用比较大的进程栈空间，会造成进程栈溢出的危险。因此我们可以自己用栈模拟递归过程，即每次从栈顶取出一部分做划分之后，都把新的两部分的起始位置分别入栈。（4） 堆排序：利用大顶堆（或者小顶堆）堆顶记录的是最大关键字（最小关键字）这一特性，实现对序列的排序。以大顶堆为例。首先，将初始待排序关键字序列（R1，R2…Rn）构建成一个大顶堆，此时的堆为初始的无序区。然后，将堆顶的元素R1与最后一个元素Rn交换，此时得到新的无序区（R1，R2…Rn-1）和新的有序区（Rn），且此时满足R1，R2…Rn-1 &lt;= Rn。经过如上的交换之后，新的顶堆可能违反大顶堆的性质，因此需要对新产生的无序区（R1，R2…Rn-1）进行调整使之成为新的大顶堆，然后再将R1与Rn-1（无序区中最后一个元素）进行交换。不断重复以上过程直至有序区中的元素个数达到n-1个为止，完成整个排序过程。 设计思路： （1） 冒泡排序：冒泡排序需要用到双重循环。首先，实现内层循环，即进行相邻元素之间的比较，该调换顺序的调换顺序，不用调换顺序的进行下一位的比较。其次，再实现外层循环，根据冒泡排序的思想，每次内循环结束后，都会有一个最小值（或者最大值）到达它最终应该到达的位置，因此下一趟内循环的比较次数就减少一次，于是我们应该在外循环中控制内层循环的次数。内层循环结束退出后，外层循环减一再进入内循环。为了防止有序序列已经出现的时候，我们的循环还在运行，不妨设置一个标志位，初始为0，如果在内部循环中发生了交换则将其置为1。如果内层循环结束后，我们的标志位仍为0，则表示我们的序列已经有序，无需再继续执行下去，此时便可以返回当前的有序序列了。（2） 快速排序（递归）：快排的设计思路基于分治法。首先，选取一个元素作为切分元素pivot，然后基于pivot把数组切分为三部分：左子数组（元素小于或者等于pivot），pivot，右子数组（元素大于pivot）。然后，递归地对左右两个子数组进行快速排序，只要保证左右两个子数组分别有序，整个数组也就有序了。（3） 快速排序（非递归）：自己构造一个栈，栈中存放待排序数组的起始位置和终止位置，然后将整个数组的起始位置s和终止位置e入栈，然后从s到e依次对出栈数据进行排序，找到基准数据最终的位置p。在基准位置左侧，判断起始位置s是否小于基准位置p-1，如果小于则将起始位置和新的终点(p-1)位置进栈。同理，在基准位置右侧，判断e是否大于基准位置p+1，若大于则将p+1作为起始位置，e作为终点位置进栈。在这两个新的栈中找到各自的基准数据的最终位置。如此往复直至栈空。（4） 堆排序：堆排序中关键的就是建立大顶堆的过程和调整过程，而调整过程是最为重要的。从最末非叶节点（根据树的结构，不难得出这个位置为Array.length/2向下取整）开始，然后依次往前调整；然后我们再讨论调整过程，首先和当前节点的左子女进行比较，用一个值largest记录比较出来的比较大的那个值的index，然后再让这个largest所代表的值与该节点的右子女进行比较，依旧用largest记录较大值的index，最后比较当前节点与这个largest所代表的值，如果相等说明我们当前节点就是这个三节点两层子树的最大值，如果不相等，我们应该将这个值与我们当前的节点（子树父节点）交换。按照以上步骤建立大顶堆，然后将大顶堆堆顶的值与该树的最后一个节点进行交换，此时便分出来两个区，也就是我们算法思想中提到的无序区和有序区。交换之后的，再对新的Array进行新一轮的调整。为了方便，我同时也实现了一个数组的工具类，它有两个功能，一是打印Array；另一个功能就是实现两个数的交换功能。 程序代码： （1） 冒泡排序： class BubbleSort &#123;1234567891011121314151617181920212223242526 public static void main(String[] args) &#123; // TODO Auto-generated method stub int A[] = &#123; 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 &#125;; BubbleSort(A, 10); for (int i = 0; i &lt; 10; i++) &#123; System.out.print(A[i] + &quot; &quot;); &#125;&#125; public static void BubbleSort(int A[], int n) &#123; boolean flag = false; int temp; for (int i = 0; i &lt; n - 1; i++) &#123; flag = false; for (int j = n - 1; j &gt; i; j--) if (A[j - 1] &gt; A[j]) &#123; temp = A[j - 1]; A[j - 1] = A[j]; A[j] = temp; flag = true; &#125; if (flag == false) return; &#125;&#125;&#125; （2） 快速排序： class QuickSort &#123;1234567891011121314151617181920212223242526272829303132 public static void main(String[] args) &#123; int A[] = &#123; 1, 5, 8, 2, 4, 6, 3, 7, 9, 0 &#125;; int low = 0; int high = A.length - 1; QuickSort(A, low, high); for (int i = 0; i &lt; A.length; i++) &#123; System.out.print(A[i] + &quot; &quot;); &#125;&#125;public static void QuickSort(int A[], int low, int high) &#123; if (low &lt; high) &#123; int pivotpos = Partition(A, low, high); QuickSort(A, low, pivotpos - 1); QuickSort(A, pivotpos + 1, high); &#125;&#125;public static int Partition(int A[], int low, int high) &#123; int pivot = A[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) --high; A[low] = A[high]; while (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125;&#125; （3） 快速排序非递归方式实现： class QuickSortNonRecursion &#123;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 public static void main(String[] args) &#123; int A[] = &#123; 1, 5, 8, 2, 4, 6, 3, 7, 9, 0 &#125;; int low = 0; int high = A.length - 1; nonRec_quickSort(A, low, high); for (int i = 0; i &lt; A.length; i++) &#123; System.out.print(A[i] + &quot; &quot;); &#125;&#125;public static void nonRec_quickSort(int[] a, int start, int end) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if (start &lt; end) &#123; stack.push(end); stack.push(start); while (!stack.isEmpty()) &#123; int l = stack.pop(); int r = stack.pop(); int index = partition(a, l, r); if (l &lt; index - 1) &#123; stack.push(index - 1); stack.push(l); &#125; if (r &gt; index + 1) &#123; stack.push(r); stack.push(index + 1); &#125; &#125; &#125; System.out.println(Arrays.toString(a));&#125;public static int partition(int[] a, int start, int end) &#123; int pivot = a[start]; while (start &lt; end) &#123; while (start &lt; end &amp;&amp; a[end] &gt;= pivot) end--; a[start] = a[end]; while (start &lt; end &amp;&amp; a[start] &lt;= pivot) start++; a[end] = a[start]; &#125; a[start] = pivot; return start;&#125;&#125; （4） 堆排序： 核心代码： class HeapSort &#123;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public static void main(String[] args) &#123; int[] array = &#123; 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3 &#125;; System.out.println(&quot;Before heap:&quot;); ArrayUtils.printArray(array); heapSort(array); System.out.println(&quot;After heap sort:&quot;); ArrayUtils.printArray(array); &#125; public static void heapSort(int[] array) &#123; if (array == null || array.length &lt;= 1) return; buildMaxHeap(array); for (int i = array.length - 1; i &gt;= 1; i--) &#123; ArrayUtils.exchangeElements(array, 0, i); maxHeap(array, i, 0); &#125; &#125; private static void buildMaxHeap(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; int half = array.length / 2; for (int i = half; i &gt;= 0; i--) &#123; maxHeap(array, array.length, i); &#125; &#125; private static void maxHeap(int[] array, int heapSize, int index) &#123; int left = index * 2 + 1; int right = index * 2 + 2; int largest = index; if (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123; largest = right; &#125; if (index != largest) &#123; ArrayUtils.exchangeElements(array, index, largest); maxHeap(array, heapSize, largest); &#125; &#125;&#125; 工具类： class ArrayUtils &#123;1234567891011121314151617 public static void printArray(int[] array) &#123; System.out.print(&quot;&#123;&quot;); for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i]); if (i &lt; array.length - 1) &#123; System.out.print(&quot;,&quot;); &#125; &#125; System.out.println(&quot;&#125;&quot;); &#125; public static void exchangeElements(int[] array, int index1, int index2) &#123; int temp = array[index1]; array[index1] = array[index2]; array[index2] = temp; &#125;&#125; 测试例及运行结果： （1） 冒泡排序：{10,9,8,7,6,5,4,3,2,1} ==&gt; {1,2,3,4,5,6,7,8,9,10}{1,5,8,2,4,6,3,7,9,0} ==&gt; {0,1,2,3,4,5,6,7,8,9}（2） 快速排序（递归与非递归测试例相同）：{10,9,8,7,6,5,4,3,2,1} ==&gt; {1,2,3,4,5,6,7,8,9,10}{1,5,8,2,4,6,3,7,9,0} ==&gt; {0,1,2,3,4,5,6,7,8,9}（3） 堆排序： Before heap: {9,8,7,6,5,4,3,2,1,0,-1,-2,-3} After heap sort:{-3,-2,-1,0,1,2,3,4,5,6,7,8,9} 分析： （1） 冒泡排序：最好情况：对象的初始排列是按关键码从小到大排好序时，此算法只执行一次冒泡排序，做n-1次的关键码比较，不需要移动对象。最坏情况：算法执行了n-1次冒泡，第i次（1&lt;=i&lt;=n）做了n-i次关键码比较，执行了n-i次对象交换。因此这种情况下，总的关键码比较次数KCN和对象移动次数RMN为： 空间复杂度：需要一个附加对象以实现对象值的对换。冒泡排序是一个稳定的排序算法。（2） 快速排序（递归）：快速排序的趟数取决于递归树的深度。 最理想情况下时间复杂度分析：每次划分后，该对象的左右两侧的子序列长度相同。总的时间复杂度T(n)= o(n log2n )最坏情况下时间复杂度分析：每次划分后，有一个子序列是空的，此时T(n)=O(n2)平均情况：T(n)= o(n log2n ) 最好情况下空间复杂度分析：由于算法是递归的，需要一个栈存放每层递归调用时的指针和参数。递归的深度就是树的深度，因此此时的存储开销为o(log2n)。最坏情况下空间复杂度分析：此时递归树为单支树，存储开销为o(n)。 快速排序是不稳定的排序算法。（3） 快速排序（非递归）：该算法对比递归算法，它使用的栈是我们自己创建的栈。而递归方法使用的是程序自动产生的栈，栈中包含了函数调用时的参数和函数中的局部变量。如果局部变量很多或者函数内部有调用了其他函数，这样一来，栈就会变得很大，每次递归调用都要操作很大的栈，效率自然会下降。而我们自己创建的栈，不管程序的复杂度如何，都不会影响程序的效率。该算法的平均情况的时间复杂度仍是o(n log2n )。（4） 堆排序：时间复杂度分析：初始化大顶堆过程每个非叶节点都用到了调整过程的算法，因此该层循环所用时间为： n 其中，i 是层序号，2i 是第 i 层的最大结点数，(k-i-1)是第 i 层结点能够 移动的最大距离。化简后： 调整循环过程：该循环的计算时间为O(nlog2n)。所以，堆排序的时间复杂度为O(nlog2n)。空间复杂度分析：附加存储主要在调整过程中占用，执行交换需要使用一个临时存储空间，因此空间复杂度为O(1)。堆排序是一个不稳定的排序算法。 以上是作业的主要内容，如果有不正确或者有异议的地方，还希望大家不吝指正。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"Deep Learning学习笔记（一）","date":"2017-10-19T01:28:30.000Z","path":"2017/10/19/Deep-Learning学习笔记（一）/","text":"&gt;","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"新的开始","date":"2017-08-31T13:32:57.000Z","path":"2017/08/31/新的开始/","text":"今天是开学第二天，经过大学最后一个暑假的糙磨之后终于迎来了开学，虽然还是我的内蒙古大学，虽然还是计算机学院，但是我对新的开始还是充满了向往。 今年是自治区70周年大庆，内蒙古大学60周年大庆，计算机学院20周年庆，从年初开始呼市就各种修，用欣欣向荣形容这一切可能太过于文雅，暑假之后回来之后确实感觉呼市大变样，花花草草变多了，乱七八糟的广告牌子也整理的比较顺眼了，学校里面更是没得说，最起码有好几段路比原来平整多了。 这两天给我最大的感触就是物是人非，同学们都各奔前程了，学校还是老样子，桃李湖风景依旧。28号的时候来学校这边逛了一圈，偶然遇见了之惠姐姐来学校取档案，还是像往常一样的跟惠姐打了个招呼，聊了几句之后就道别了，但是就在说再见的那一刻才意识到，以后这样的见面的机会也许只能交给缘分了。原来我们真的已经毕业了。 宿舍从本区搬到了东区，原来的六人间变成了四人间。新宿舍上床下桌的环境还是很令人心喜的，宿舍楼底下还有篮球场，虽然没上场打一会，但是只是静静的站在旁边看一会就很令人心满意足了，还有好多学生在灯下玩滑板，还有校园广播中持续不断的流行歌曲，还有好多好多好多好多值得分享的东西。。。。 本科的时候很喜欢跟舍友网吧五连坐，大家一起(｡･∀･)ﾉﾞ嗨，一起玩就感觉很棒，现在更喜欢一个人静静的坐着，听会歌，看看风景，难道是因为我老了？可能只是心气不一样了吧，也可能是因为现在不是很容易找齐5个人再到网吧坐会了吧。 最近最不能释怀的还是我的狼人杀小分队，虽然大家在一起的时光不是很长，但是革命友谊胜过一切，大家一起谈天说地，一起打大A，当然最有意思的狼人杀，还是很怀念那几天的游戏气氛，很棒。还有最后一句，我是预言家（手动滑稽）。 这两天见了导师，认识了新的同学，买了新装备，感觉还是棒棒哒。 明天就是开学典礼了，希望明天又是美好的一天。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://cliugeek9229.github.io/tags/随笔/"}]},{"title":"git 学习总结（二）","date":"2017-06-21T01:09:19.000Z","path":"2017/06/21/git-学习总结2/","text":"没错，这是接着上一次的博客写的。 1.上次说到了日志查看操作，后来在评论区看到了git reflog 命令。 git会记录你的每一次修改HEAD的操作，通过git reflog可以查看所有的历史操作记录，它等同于git log -g 命令。git log命令会显示你所有的提交记录，仅是commit，而git reflog是显示所有操作记录，还包括checkout、merge和reset记录。 2.现在我们既然会查看了，那么接下来就是版本回退了。命令如下： 回退到当前版本的上一个版本 $ git reset –hard HEAD^ 回退到当前版本的上两个版本 $ git reset –hard HEAD^^ 可能机智的你发现了这个^的作用，但是问题又来了，比如你想回到前100个版本，你不会想打100个^吧，这得多虐。那么简便方式来了： $ git reset –hard HEAD~100 其实我们也可以不必数需要回退的版本是当前版本的前多少个版本，通过指定版本号也可以会回退到指定的版本： $ git reset –hard 1234567890 没错，版本号就是你通过git log可以查看到的那串超长的乱七八糟的十六进制数，还有，就是这个版本号写前几位就行，没必要写全，但是也不能太短，能让系统识别出来是哪个版本就行，长度自己斟酌就好。 可能大家会对这个 –hard 参数有疑问，没有？那同学你就太没灵性了。就当大家都有疑问，那这个参数的作用是什么？ 答：git reset操作是撤销了你做的更改，但是除了当前分支上的操作，你可能还需要传入一些标记来修改你的缓存区或工作目录，所以： –soft – 缓存区和工作目录都不会被改变 –mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响 –hard – 缓存区和工作目录都同步到你指定的提交 关于这个知识点，如果你还想再了解些其他的内容，我可以给你提供一个网址，没错，就是 它 。 3.既然我们提到了工作区和版本库，所以就有必要再总结下这俩东西 工作区的概念很简单，就是你本机上的那个文件夹，这个文件夹就是你的工作区，但是不包括其中的.git隐藏文件夹。 版本库就是我们刚才说的这个隐藏文件夹。 其实git的版本库里面有很多的内容，但是我们需要了解的就是其中最为重要的stage（或者index），学名叫做暂存区，此外，git还为我们自动创造了第一个branch，名为master，以及指向master的一个指针，叫做HEAD。 这时候我们就需要盗个图（来自廖雪峰的官方网站-git教程）来解释下他们的关系了。如下： 4.对了，其实有很多简单的操作也需要我们了解。 比如查看修改文件内容，创建删除文件啊之类的操作，其实这些东西大家自己去百度下就能找的到，而且肯定比博主说的详细， 这里 其实有一个网址，我感觉不错，推荐给大家。另外，这也有一个关于vi操作的网址推荐，拿走不蟹。 5.撤销修改 比如我们在工作区中选一个文件并对其进行修改，这时候我们发现，内容写错了，需要将版本回退到我们上次提交时的状态，使用git status命令查看当前状态，然后git就会告诉我们可以用git checkout – &lt; file &gt;来丢弃工作区的修改： $ git checkout – XXX.YYY 其实上面的命令有两种适用情况： （1）文件修改后尚未添加到暂存区，撤销之后就回到了与版本库一样的状态了。 （2）文件修改后我们又将其添加到了暂存区，这个时候我们并没有直接commit，而是又将文件做了新的修改，现在执行撤销修改命令后，文件就回到了添加到暂存区之后的状态了。 也就是说这个命令可以使文件回到最近一次git commit或者git add时的状态。 比如说你现在正处于第二种状态，通过git checkout – XXX.YYY命令已经将你写的第二次错误撤销了，但是你提交给暂存区的文件里仍存有你的第一次错误，所以你还需要将暂存区的文件再给撤销回来，此时同样使用git status命令查看下当前的状态，此时git会告诉你使用git reset HEAD file可以将暂存区的修改撤销掉（也就是以unstage结尾的那句话），并将其重新放回到工作区： $ git reset HEAD XXX.YYY 此时如果你用git status查看当前状态就会发现，changes not staged for commit，也就是说咱们的暂存区是干净的，但是工作区是有修改的，所以你可以再使用git checkout命令将你需要撤销的东西撤销了，或者直接手动修改文件，如果你记得需要改什么东西的话。 有灵性的同学可能又会问，我如果不仅git add了，而且git commit了，但是并没有将本地的版本库推送到远程，我们怎么办呢？其实很简单，版本回退不就好了~~~这时候可能又有有问题的同学举手说，我要是也将本地的版本库推送到了远程怎么办？额。。。我只能告诉你Good Game了，所以大家提交东西的时候一定要慎之又慎，尤其是推送到远端的时候。 6.文件删除。 这个就比较简单了，我们都知道在文件管理器中我们可以使用rm file命令就可以删除相应的文件，要是我们想删除版本库的某个文件怎么办？也很简单，使用git rm file就可以删除相应的文件，但是我们还需要再commit一下，告诉一下版本库我们的修改： $ git rm XXX.YYY $ git commit -m “romove balabala~~~~” 这样我们就完成了对版本库中的文件的删除操作。 如果你是不小心将工作区的文件删除了怎么办？这时候我们的版本库中仍然有相应的文件，我们只需要恢复下这个文件即可： $ git checkout – XXX.YYY git checkout 其实就是将版本库里的版本替换掉工作区的版本。这样你就获取到了版本库中最新的一次版本，但是你如果在XXX.YYY中已经修改了部分信息，而这部分信息也会随着你的误删丢失了，所以，小心看护你的工作区。 以上，是我对于廖神的git教程中时光机穿梭这一章的总结。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"git 学习总结（一）","date":"2017-06-20T14:27:37.000Z","path":"2017/06/20/git-学习总结/","text":"最近把廖神的git教程重温一遍，这篇博客主要是针对git中的命令，稍作总结。 1.博主的环境是win10，按照默认配置安装完git。之后，我们需要设置我们自己的用户名和默认的邮箱地址。 右键桌面，在出现的菜单中选择“Git Bash”选项，通过cd命令到达指定的文件夹下【或者你直接到指定的目目录下之后，然后右键空白处点击右键然后选择git bash here选项】，再通过键入以下命令完成设置： $ git config –global user.name “Leno” $ git config –global user.email “XXX@YYY.com” 注意下这里的–global参数，这个参数说明我们当前机器下的所有的git仓库都是用的这个用户名和邮箱。 2.创建版本库。 $ git init 3.分两步，将文件添加到git仓库。 3.1 将文件添加到暂存区（可多次添加文件，也可一次添加多个文件） $ git add XXX.YYY 3.2 将文件添提交到仓库 $ git commit -m “bala~bala~bala~” 4.查阅当前仓库的状态 $ git status 5.查阅文件具体被修改的内容 $ git diff XXX.YYY 6.查看从最近到最远的提交日志 $ git log 当然，这种显示日志简直low到炸，这时候我们可以通过一个参数添加达到让这些日志显示到一行上，具体命令如下： $ git log –pretty=oneline 这样显示出来的日志结果倒是简洁了不少，但是还不是令人特别满意，那么此时你可以试一下以下的这串命令： $ git log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit 这时候你会说，我不就是想看一下日志嘛，如果每次都输入这么一长串的命令，这样会耽误很长的时间，那岂不是很蠢。。。也对，每次都输入这么一长串命令确实斯丢屁德，那么怎么办呢，方法还是有的，既然你来访问我的博客，那你我就是有缘人，既然是有缘人，那我就不吝指教了。我们可以通过配置别名的方法来简化以上的这行命令，如下： $ git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit” 这样配置完之后，你再试一下： $ git lg 意不意外？惊不惊喜？高不高兴？关于配置别名在后边会又详细的叙述，今天就先到这。","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://cliugeek9229.github.io/tags/学习心得/"}]},{"title":"忙点好~忙点好~","date":"2017-06-16T11:58:20.000Z","path":"2017/06/16/忙点好-忙点好/","text":"这几天还真的是挺忙的，这样其实也挺充实的，最起码可以不让我老是窝宿舍。 其实这几天感触还是很多的，先是整理学籍表，自己忙了一天半还多，最让人心寒的是干活的时候叫人叫不来，回家的、去工作的我都能理解，大家其实都很忙，我真的能理解，但是，我最不能理解的就是装作没这回事的同学，还有因为在打游戏不能帮忙的，简直想送他们一句mmp。 毕竟大家在一起的日子也不是很多了，本来站好最后一班岗也是情理之中，但是大家对我们工作的支持态度也太差了，这个绝对是班委的预料之外的。。。 现在想想其实自己的问题也很大，做事不能太耿直，也不能一不顺心就摔脸子，这样不但不能解决问题，而且还会使得矛盾激化，以后可得好好收敛下自己的情绪了，不能想个小孩一样。 今天又被教务处抓去做了次壮丁，说好的只是核对班级的毕业信息，结果各种活都来了。。。先是去抱本科生的期末试卷，然后又是毕业证和学位证，可是累的不轻。 这几天虽然有些累，但总的来说，还是不错的。 现在洗脚听歌写博客也是很惬意的~~希望明天的六级考试能上300分吧，作为一名裸考考生，300我就已经很知足了【手动捂脸】","tags":[{"name":"随笔","slug":"随笔","permalink":"http://cliugeek9229.github.io/tags/随笔/"}]},{"title":"博客处女作","date":"2017-06-07T13:37:06.000Z","path":"2017/06/07/博客处女作/","text":"欢迎大家来到我的博客！在旭哥哥不懈地指导下，我的博客总算是搭建起来了。在这个博客上面我会不定期地发布个人随笔、读书笔记等。 去年冬天的时候就已经在廖雪峰的官方网站上学习过git的相关知识了，但仅仅只是学习一些基本的操作，并没有具体的将它用于项目中，结果就是感动了自己，浪费了时间，最后也没有学到多少东西，简直斯丢匹德。 学习其实不仅仅只是态度的问题，方法也很重要，以后这种感动自己的事还是不干的好… 本来想着关于技术博客也写在这个博客上，但是想到如果这样的话，无法供世人瞻仰，所以我准备把技术相关的博客写到CSDN上，这样的话，也是极好的。 现在这个写作水平啊，也是没谁了（手动无奈）。 最后还是欢迎大家常来我的博客逛一逛，当然，要是能顺便关爱一下博主就更好了（手动滑稽）。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://cliugeek9229.github.io/tags/随笔/"}]}]